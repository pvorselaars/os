#include "video.h"

// Basic 8x16 font data for ASCII characters 0x20-0x7F
// Each character is 16 bytes (16 rows of 8 pixels each)
static const uint8_t vga_font[96][16] = {
    // 0x20 - Space
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x21 - !
    {0x00,0x00,0x18,0x3C,0x3C,0x3C,0x18,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00},
    // 0x22 - "
    {0x00,0x66,0x66,0x66,0x24,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x23 - #
    {0x00,0x00,0x00,0x6C,0x6C,0xFE,0x6C,0x6C,0x6C,0xFE,0x6C,0x6C,0x00,0x00,0x00,0x00},
    // 0x24 - $
    {0x00,0x10,0x38,0x54,0x50,0x38,0x14,0x54,0x38,0x10,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x25 - %
    {0x00,0x00,0x00,0x00,0x23,0x33,0x08,0x0C,0x06,0x33,0x31,0x00,0x00,0x00,0x00,0x00},
    // 0x26 - &
    {0x00,0x00,0x1C,0x36,0x1C,0x6E,0x3B,0x33,0x33,0x6E,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x27 - '
    {0x00,0x06,0x0C,0x18,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x28 - (
    {0x00,0x00,0x0C,0x18,0x30,0x30,0x30,0x30,0x30,0x18,0x0C,0x00,0x00,0x00,0x00,0x00},
    // 0x29 - )
    {0x00,0x00,0x30,0x18,0x0C,0x0C,0x0C,0x0C,0x0C,0x18,0x30,0x00,0x00,0x00,0x00,0x00},
    // 0x2A - *
    {0x00,0x00,0x00,0x00,0x99,0x5A,0x3C,0xFF,0x3C,0x5A,0x99,0x00,0x00,0x00,0x00,0x00},
    // 0x2B - +
    {0x00,0x00,0x00,0x00,0x18,0x18,0x18,0xFF,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00},
    // 0x2C - ,
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00},
    // 0x2D - -
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x2E - .
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00},
    // 0x2F - /
    {0x00,0x00,0x00,0x00,0x03,0x06,0x0C,0x18,0x30,0x60,0xC0,0x00,0x00,0x00,0x00,0x00},
    // 0x30 - 0
    {0x00,0x00,0x3C,0x66,0x63,0x63,0x63,0x63,0x63,0x66,0x3C,0x00,0x00,0x00,0x00,0x00},
    // 0x31 - 1
    {0x00,0x00,0x18,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00,0x00},
    // 0x32 - 2
    {0x00,0x00,0x3C,0x66,0x06,0x0C,0x18,0x30,0x60,0x66,0x7E,0x00,0x00,0x00,0x00,0x00},
    // 0x33 - 3
    {0x00,0x00,0x3C,0x66,0x06,0x1C,0x06,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00,0x00},
    // 0x34 - 4
    {0x00,0x00,0x0C,0x1C,0x3C,0x6C,0xCC,0xFE,0x0C,0x0C,0x1E,0x00,0x00,0x00,0x00,0x00},
    // 0x35 - 5
    {0x00,0x00,0x7E,0x60,0x60,0x7C,0x06,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00,0x00},
    // 0x36 - 6
    {0x00,0x00,0x1C,0x36,0x60,0x7C,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00},
    // 0x37 - 7
    {0x00,0x00,0x7E,0x66,0x06,0x0C,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00},
    // 0x38 - 8
    {0x00,0x00,0x3C,0x66,0x66,0x3C,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00},
    // 0x39 - 9
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x3E,0x06,0x6C,0x38,0x00,0x00,0x00,0x00,0x00},
    // 0x3A - :
    {0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00},
    // 0x3B - ;
    {0x00,0x00,0x00,0x00,0x18,0x18,0x00,0x00,0x00,0x18,0x18,0x30,0x00,0x00,0x00,0x00},
    // 0x3C - <
    {0x00,0x00,0x00,0x06,0x0C,0x18,0x30,0x60,0x30,0x18,0x0C,0x06,0x00,0x00,0x00,0x00},
    // 0x3D - =
    {0x00,0x00,0x00,0x00,0x00,0x7E,0x00,0x00,0x7E,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x3E - >
    {0x00,0x00,0x00,0x60,0x30,0x18,0x0C,0x06,0x0C,0x18,0x30,0x60,0x00,0x00,0x00,0x00},
    // 0x3F - ?
    {0x00,0x00,0x3C,0x66,0x66,0x0C,0x18,0x18,0x00,0x18,0x18,0x00,0x00,0x00,0x00,0x00},
    // 0x40 - @
    {0x00,0x00,0x3C,0x66,0x6E,0x6E,0x60,0x62,0x3C,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x41 - A
    {0x00,0x00,0x18,0x3C,0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00},
    // 0x42 - B
    {0x00,0x00,0x7C,0x66,0x66,0x7C,0x66,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00,0x00},
    // 0x43 - C
    {0x00,0x00,0x3C,0x66,0x60,0x60,0x60,0x60,0x60,0x66,0x3C,0x00,0x00,0x00,0x00,0x00},
    // 0x44 - D
    {0x00,0x00,0x78,0x6C,0x66,0x66,0x66,0x66,0x66,0x6C,0x78,0x00,0x00,0x00,0x00,0x00},
    // 0x45 - E
    {0x00,0x00,0x7E,0x60,0x60,0x78,0x60,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00,0x00},
    // 0x46 - F
    {0x00,0x00,0x7E,0x60,0x60,0x78,0x60,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,0x00},
    // 0x47 - G
    {0x00,0x00,0x3C,0x66,0x60,0x60,0x6E,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00},
    // 0x48 - H
    {0x00,0x00,0x66,0x66,0x66,0x7E,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00},
    // 0x49 - I
    {0x00,0x00,0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x7E,0x00,0x00,0x00,0x00,0x00},
    // 0x4A - J
    {0x00,0x00,0x1E,0x0C,0x0C,0x0C,0x0C,0x0C,0x6C,0x6C,0x38,0x00,0x00,0x00,0x00,0x00},
    // 0x4B - K
    {0x00,0x00,0x66,0x6C,0x78,0x70,0x78,0x6C,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00},
    // 0x4C - L
    {0x00,0x00,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00,0x00},
    // 0x4D - M
    {0x00,0x00,0x63,0x77,0x7F,0x6B,0x63,0x63,0x63,0x63,0x63,0x00,0x00,0x00,0x00,0x00},
    // 0x4E - N
    {0x00,0x00,0x66,0x76,0x7E,0x7E,0x6E,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00},
    // 0x4F - O
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00},
    // 0x50 - P
    {0x00,0x00,0x7C,0x66,0x66,0x7C,0x60,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,0x00},
    // 0x51 - Q
    {0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x0E,0x00,0x00,0x00,0x00,0x00},
    // 0x52 - R
    {0x00,0x00,0x7C,0x66,0x66,0x7C,0x78,0x6C,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00},
    // 0x53 - S
    {0x00,0x00,0x3C,0x66,0x60,0x30,0x18,0x0C,0x06,0x66,0x3C,0x00,0x00,0x00,0x00,0x00},
    // 0x54 - T
    {0x00,0x00,0x7E,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00},
    // 0x55 - U
    {0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00},
    // 0x56 - V
    {0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x66,0x66,0x3C,0x18,0x00,0x00,0x00,0x00,0x00},
    // 0x57 - W
    {0x00,0x00,0x63,0x63,0x63,0x6B,0x7F,0x77,0x63,0x63,0x63,0x00,0x00,0x00,0x00,0x00},
    // 0x58 - X
    {0x00,0x00,0x66,0x66,0x3C,0x18,0x3C,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00},
    // 0x59 - Y
    {0x00,0x00,0x66,0x66,0x66,0x3C,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00},
    // 0x5A - Z
    {0x00,0x00,0x7E,0x06,0x0C,0x18,0x30,0x60,0x60,0x60,0x7E,0x00,0x00,0x00,0x00,0x00},
    // 0x5B - [
    {0x00,0x00,0x3C,0x30,0x30,0x30,0x30,0x30,0x30,0x30,0x3C,0x00,0x00,0x00,0x00,0x00},
    // 0x5C - backslash
    {0x00,0x00,0x00,0x80,0xC0,0x60,0x30,0x18,0x0C,0x06,0x02,0x00,0x00,0x00,0x00,0x00},
    // 0x5D - ]
    {0x00,0x00,0x3C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x0C,0x3C,0x00,0x00,0x00,0x00,0x00},
    // 0x5E - ^
    {0x10,0x38,0x6C,0xC6,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x5F - _
    {0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xFF,0x00,0x00},
    // Additional characters continue with similar patterns...
    // For brevity, I'll add a few more important ones:
    
    // 0x60 - `
    {0x00,0x30,0x18,0x0C,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x61 - a
    {0x00,0x00,0x00,0x00,0x00,0x3C,0x06,0x3E,0x66,0x66,0x3E,0x00,0x00,0x00,0x00,0x00},
    // 0x62 - b
    {0x00,0x00,0x60,0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x7C,0x00,0x00,0x00,0x00,0x00},
    // 0x63 - c
    {0x00,0x00,0x00,0x00,0x00,0x3C,0x60,0x60,0x60,0x60,0x3C,0x00,0x00,0x00,0x00,0x00},
    // 0x64 - d
    {0x00,0x00,0x06,0x06,0x06,0x3E,0x66,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00,0x00},
    // 0x65 - e
    {0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x7E,0x60,0x60,0x3C,0x00,0x00,0x00,0x00,0x00},
    // 0x66 - f
    {0x00,0x00,0x0E,0x18,0x18,0x3E,0x18,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00},
    // 0x67 - g
    {0x00,0x00,0x00,0x00,0x00,0x3E,0x66,0x66,0x66,0x3E,0x06,0x7C,0x00,0x00,0x00,0x00},
    // 0x68 - h
    {0x00,0x00,0x60,0x60,0x60,0x7C,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00},
    // 0x69 - i
    {0x00,0x00,0x18,0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,0x00},
    // 0x6A - j
    {0x00,0x00,0x06,0x00,0x00,0x06,0x06,0x06,0x06,0x06,0x66,0x3C,0x00,0x00,0x00,0x00},
    // 0x6B - k
    {0x00,0x00,0x60,0x60,0x60,0x66,0x6C,0x78,0x6C,0x66,0x66,0x00,0x00,0x00,0x00,0x00},
    // 0x6C - l
    {0x00,0x00,0x38,0x18,0x18,0x18,0x18,0x18,0x18,0x18,0x3C,0x00,0x00,0x00,0x00,0x00},
    // 0x6D - m
    {0x00,0x00,0x00,0x00,0x00,0x66,0x7F,0x7F,0x6B,0x63,0x63,0x00,0x00,0x00,0x00,0x00},
    // 0x6E - n
    {0x00,0x00,0x00,0x00,0x00,0x7C,0x66,0x66,0x66,0x66,0x66,0x00,0x00,0x00,0x00,0x00},
    // 0x6F - o
    {0x00,0x00,0x00,0x00,0x00,0x3C,0x66,0x66,0x66,0x66,0x3C,0x00,0x00,0x00,0x00,0x00},
    // 0x70 - p
    {0x00,0x00,0x00,0x00,0x00,0x7C,0x66,0x66,0x66,0x7C,0x60,0x60,0x00,0x00,0x00,0x00},
    // 0x71 - q
    {0x00,0x00,0x00,0x00,0x00,0x3E,0x66,0x66,0x66,0x3E,0x06,0x06,0x00,0x00,0x00,0x00},
    // 0x72 - r
    {0x00,0x00,0x00,0x00,0x00,0x7C,0x66,0x60,0x60,0x60,0x60,0x00,0x00,0x00,0x00,0x00},
    // 0x73 - s
    {0x00,0x00,0x00,0x00,0x00,0x3E,0x60,0x3C,0x06,0x06,0x7C,0x00,0x00,0x00,0x00,0x00},
    // 0x74 - t
    {0x00,0x00,0x00,0x18,0x18,0x7E,0x18,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00,0x00},
    // 0x75 - u
    {0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x66,0x3E,0x00,0x00,0x00,0x00,0x00},
    // 0x76 - v
    {0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x3C,0x18,0x00,0x00,0x00,0x00,0x00},
    // 0x77 - w
    {0x00,0x00,0x00,0x00,0x00,0x63,0x63,0x6B,0x7F,0x77,0x63,0x00,0x00,0x00,0x00,0x00},
    // 0x78 - x
    {0x00,0x00,0x00,0x00,0x00,0x66,0x3C,0x18,0x3C,0x66,0x66,0x00,0x00,0x00,0x00,0x00},
    // 0x79 - y
    {0x00,0x00,0x00,0x00,0x00,0x66,0x66,0x66,0x66,0x3E,0x0C,0x78,0x00,0x00,0x00,0x00},
    // 0x7A - z
    {0x00,0x00,0x00,0x00,0x00,0x7E,0x0C,0x18,0x30,0x60,0x7E,0x00,0x00,0x00,0x00,0x00},
    // 0x7B - {
    {0x00,0x00,0x0E,0x18,0x18,0x18,0x70,0x18,0x18,0x18,0x0E,0x00,0x00,0x00,0x00,0x00},
    // 0x7C - |
    {0x00,0x00,0x18,0x18,0x18,0x18,0x00,0x18,0x18,0x18,0x18,0x00,0x00,0x00,0x00,0x00},
    // 0x7D - }
    {0x00,0x00,0x70,0x18,0x18,0x18,0x0E,0x18,0x18,0x18,0x70,0x00,0x00,0x00,0x00,0x00},
    // 0x7E - ~
    {0x00,0x00,0x76,0xDC,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00},
    // 0x7F - DEL
    {0x00,0x00,0x00,0x00,0x10,0x38,0x6C,0xC6,0xC6,0xFE,0x00,0x00,0x00,0x00,0x00,0x00}
};

void vga_load_font(void) {
    // Save current state
    uint8_t seq2, seq4, gc5, gc6;
    
    // Read current sequencer register 2 and 4
    outb(0x3C4, 0x02);
    seq2 = inb(0x3C5);
    outb(0x3C4, 0x04);
    seq4 = inb(0x3C5);
    
    // Read current graphics controller register 5 and 6
    outb(0x3CE, 0x05);
    gc5 = inb(0x3CF);
    outb(0x3CE, 0x06);
    gc6 = inb(0x3CF);
    
    // Set up sequencer for font loading
    // Turn off even/odd (allow access to full memory)
    outb(0x3C4, 0x02);
    outb(0x3C5, 0x04); // Select plane 2
    outb(0x3C4, 0x04);
    outb(0x3C5, 0x07); // Sequential mode
    
    // Set up graphics controller for font loading
    outb(0x3CE, 0x05);
    outb(0x3CF, 0x00); // Disable odd/even, enable all planes
    outb(0x3CE, 0x06);
    outb(0x3CF, 0x00); // Map to A0000-AFFFF
    
    // Load font data into video memory plane 2
    volatile uint8_t* font_mem = (volatile uint8_t*)0xA0000;
    
    // Clear font memory first
    for (int i = 0; i < 256 * 32; i++) {
        font_mem[i] = 0;
    }
    
    // Load our font data (characters 0x20-0x7F)
    for (int char_index = 0; char_index < 96; char_index++) {
        int char_code = char_index + 0x20; // Start from space character
        uint8_t* char_ptr = (uint8_t*)(font_mem + char_code * 32);
        
        // Copy 16 bytes of font data for this character
        for (int row = 0; row < 16; row++) {
            char_ptr[row] = vga_font[char_index][row];
        }
    }
    
    // Restore original state
    outb(0x3C4, 0x02);
    outb(0x3C5, seq2);
    outb(0x3C4, 0x04);
    outb(0x3C5, seq4);
    outb(0x3CE, 0x05);
    outb(0x3CF, gc5);
    outb(0x3CE, 0x06);
    outb(0x3CF, gc6);
}

void vga_load_font_simple(void) {
    // Set sequencer to allow access to all planes
    outb(0x3C4, 0x02);
    outb(0x3C5, 0x04); // Enable plane 2
    outb(0x3C4, 0x04);
    outb(0x3C5, 0x06); // Disable odd/even, enable extended memory
    
    // Set graphics controller
    outb(0x3CE, 0x05);
    outb(0x3CF, 0x00); // Write mode 0
    outb(0x3CE, 0x06);
    outb(0x3CF, 0x04); // Map A0000-AFFFF, odd/even disabled
    
    // Load font data
    volatile uint8_t* font_mem = (volatile uint8_t*)0xA0000;
    
    // Load just a few test characters first
    for (int char_code = 0x20; char_code <= 0x7E; char_code++) {
        int font_index = char_code - 0x20;
        if (font_index < 96) {
            volatile uint8_t* char_ptr = font_mem + char_code * 32;
            for (int row = 0; row < 16; row++) {
                char_ptr[row] = vga_font[font_index][row];
            }
        }
    }
    
    // Reset to text mode
    outb(0x3C4, 0x02);
    outb(0x3C5, 0x03); // Enable planes 0,1
    outb(0x3C4, 0x04);
    outb(0x3C5, 0x03); // Odd/even, no extended memory
    outb(0x3CE, 0x05);
    outb(0x3CF, 0x10); // Odd/even mode
    outb(0x3CE, 0x06);
    outb(0x3CF, 0x0E); // Map B8000-BFFFF, text mode
}

void vga_init()
{
    outb(0x3C4, 0x01);
    outb(0x3C5, 0x21); 

    // 1. Misc Output: color, clock, enable video
    outb(VGA_MISC_WRITE, 0x67);

    // 2. Sequencer setup
    // Reset sequencer
    outb(0x3C4, 0x00); outb(0x3C5, 0x01); // synchronous reset

    // Write registers 1-4
    outb(0x3C4, 0x01); outb(0x3C5, 0x00);
    outb(0x3C4, 0x02); outb(0x3C5, 0x03);
    outb(0x3C4, 0x03); outb(0x3C5, 0x00);
    outb(0x3C4, 0x04); outb(0x3C5, 0x02);

    // End reset
    outb(0x3C4, 0x00); outb(0x3C5, 0x03);

    // 3. Unlock CRTC registers
    outb(VGA_CRTC_INDEX, 0x11);
    outb(VGA_CRTC_DATA, inb(VGA_CRTC_DATA) & 0x7F);

    // 4. Minimal CRTC for 80x25 text mode
    uint8_t crtc[25] = {
        0x5F,0x4F,0x50,0x82,0x55,0x81,0xBF,0x1F,
        0x00,0x4F,0x0D,0x0E,0x00,0x00,0x00,0x00,
        0x9C,0x8E,0x8F,0x28,0x1F,0x96,0xB9,0xA3,0xFF
    };
    for (int i = 0; i < 25; i++) {
        outb(VGA_CRTC_INDEX, i);
        outb(VGA_CRTC_DATA, crtc[i]);
    }

    // 5. Graphics Controller
    uint8_t gc[9] = {0x00,0x00,0x00,0x00,0x00,0x10,0x0E,0x00,0xFF};
    for (int i = 0; i < 9; i++) {
        outb(VGA_GRAPHICS_INDEX, i);
        outb(VGA_GRAPHICS_DATA, gc[i]);
    }

    // 6. Attribute Controller
    for (int i = 0; i < 16; i++) {
        inb(VGA_INPUT_STATUS);       // reset flip-flop
        outb(VGA_ATTR_INDEX, i);     // select palette index
        outb(VGA_ATTR_INDEX, i);     // identity mapping
    }

    // Mode control + overscan + plane enable + unblank
    inb(VGA_INPUT_STATUS);
    outb(VGA_ATTR_INDEX, 0x10); outb(VGA_ATTR_INDEX, 0x0C); // text mode
    inb(VGA_INPUT_STATUS);
    outb(VGA_ATTR_INDEX, 0x11); outb(VGA_ATTR_INDEX, 0x00); // overscan black
    inb(VGA_INPUT_STATUS);
    outb(VGA_ATTR_INDEX, 0x12); outb(VGA_ATTR_INDEX, 0x0F); // all planes
    inb(VGA_INPUT_STATUS);
    outb(VGA_ATTR_INDEX, 0x13); outb(VGA_ATTR_INDEX, 0x08); // no panning
    inb(VGA_INPUT_STATUS);
    outb(VGA_ATTR_INDEX, 0x14); outb(VGA_ATTR_INDEX, 0x00); // color select

    inb(VGA_INPUT_STATUS);
    outb(VGA_ATTR_INDEX, 0x20); // unblank screen

    outb(0x3C4, 0x01);
    outb(0x3C5, 0x00); // Screen on, normal clocking

    // 7. Test without custom font first
    volatile uint8_t* vga = (volatile uint8_t*)0xB8000;
    const char* msg = "Before font load";
    for (int i = 0; msg[i]; i++) {
        vga[i*2] = msg[i];   // character
        vga[i*2+1] = 0x0F;   // white on black
    }
    
    // Small delay to see the text
    for (volatile int delay = 0; delay < 10000000; delay++);

    // 8. Load our custom font (try the simple version first)
    vga_load_font_simple();

    // 9. Test after font loading
    const char* msg2 = "After font load ";
    for (int i = 0; msg2[i]; i++) {
        vga[i*2] = msg2[i];   // character
        vga[i*2+1] = 0x0A;   // light green on black
    }
  
}

void vga_init_basic()
{
    outb(0x3C2, 0x67);

    // Reset sequencer
    outb(0x3C4, 0x00); outb(0x3C5, 0x01); // synchronous reset
    outb(0x3C4, 0x01); outb(0x3C5, 0x00); 
    outb(0x3C4, 0x02); outb(0x3C5, 0x0F);
    outb(0x3C4, 0x03); outb(0x3C5, 0x00);
    outb(0x3C4, 0x04); outb(0x3C5, 0x07);
    outb(0x3C4, 0x00); outb(0x3C5, 0x03); // end reset

    // Unlock CRTC registers
    outb(0x3D4, 0x11); outb(0x3D5, 0x00);

    // Minimal CRTC settings for 80x25 text mode
    uint8_t crtc[25] = {
        0x5F,0x4F,0x50,0x82,0x55,0x81,0xBF,0x1F,
        0x00,0x4F,0x0D,0x0E,0x00,0x00,0x00,0x00,
        0x9C,0x8E,0x8F,0x28,0x1F,0x96,0xB9,0xA3,
        0xFF
    };
    for (int i = 0; i < 25; i++) {
        outb(0x3D4, i);
        outb(0x3D5, crtc[i]);
    }

    // Graphics Controller
    outb(0x3CE, 0x00); outb(0x3CF, 0x00);
    outb(0x3CE, 0x01); outb(0x3CF, 0x00);
    outb(0x3CE, 0x02); outb(0x3CF, 0x00);
    outb(0x3CE, 0x03); outb(0x3CF, 0x00);
    outb(0x3CE, 0x04); outb(0x3CF, 0x00);
    outb(0x3CE, 0x05); outb(0x3CF, 0x10);
    outb(0x3CE, 0x06); outb(0x3CF, 0x0E);
    outb(0x3CE, 0x07); outb(0x3CF, 0x0F);
    outb(0x3CE, 0x08); outb(0x3CF, 0xFF);

    // Attribute Controller
    outb(0x3C0, 0x10); outb(0x3C0, 0x0C);
    inb(0x3DA);       // reset flip-flop
    outb(0x3C0, 0x12); outb(0x3C0, 0x0F);

    inb(0x3DA);       // reset flip-flop
    for (int i = 0; i < 16; i++) {
        outb(0x3C0, i);     // select palette index
        outb(0x3C0, i);     // identity mapping
    }

    outb(0x3C0, 0x10); outb(0x3C0, 0x0C); // mode control
    outb(0x3C0, 0x12); outb(0x3C0, 0x0F); // color plane enable
    outb(0x3C0, 0x13); outb(0x3C0, 0x00); // horiz panning
    outb(0x3C0, 0x14); outb(0x3C0, 0x00); // color select
    outb(0x3C0, 0x20);                     // unblank

    volatile uint8_t* vga = (volatile uint8_t*)0xB8000;
    const char* msg = "Hello world!";
    for (int i = 0; msg[i]; i++) {
        vga[i*2] = msg[i];   // character
        vga[i*2+1] = 0xe0;   // white on black
    }
}

void vga_init_minimal() {
    // 1. Misc Output Register: select color mode, enable screen
    outb(0x3C2, 0x67);

    // 2. Sequencer: reset + basic text setup
    outb(0x3C4, 0x00); outb(0x3C5, 0x01); // async reset
    outb(0x3C4, 0x01); outb(0x3C5, 0x00); // clocking mode
    outb(0x3C4, 0x02); outb(0x3C5, 0x0F); // map mask (enable planes 0+1)
    outb(0x3C4, 0x03); outb(0x3C5, 0x00); // char map
    outb(0x3C4, 0x04); outb(0x3C5, 0x02); // memory mode (odd/even, text)
    outb(0x3C4, 0x00); outb(0x3C5, 0x03); // end reset

    // 3. Unlock CRTC
    outb(0x3D4, 0x11); outb(0x3D5, 0x00);

    // 4. CRTC registers for 80x25 text mode
    uint8_t crtc[25] = {
        0x5F, // 0: Horizontal Total (number of character clocks per line - 5Fh = 95)
        0x4F, // 1: Horizontal Display End (last displayed character column - 4Fh = 79)
        0x50, // 2: Start Horizontal Blank (column where blanking starts)
        0x82, // 3: End Horizontal Blank (upper 6 bits + bits 0–1: 82h)
        0x55, // 4: Start Horizontal Retrace (column where H-sync pulse starts)
        0x81, // 5: End Horizontal Retrace (upper 6 bits + bits 0–1: 81h)
        0xBF, // 6: Vertical Total (number of scan lines - BFh = 191)
        0x1F, // 7: Overflow (vertical total bits 8–9 + vertical retrace bits 8–9)
        0x00, // 8: Preset Row Scan (row scan start, usually 0)
        0x4F, // 9: Maximum Scan Line (rows per character - 0..15; 0x4F sets 16 scan lines)
        0x00, // 10: Cursor Start (scan line where cursor appears)
        0x0F, // 11: Cursor End (scan line where cursor disappears)
        0x00, // 12: Start Address High (high byte of start of display memory)
        0x00, // 13: Start Address Low  (low byte of start of display memory, usually 0xB8000)
        0x00, // 14: Cursor Address High (high byte of cursor offset)
        0x00, // 15: Cursor Address Low  (low byte of cursor offset)
        0x9C, // 16: Vertical Retrace Start (line where V-sync starts)
        0x8E, // 17: Vertical Retrace End (line where V-sync ends + flags)
        0x8F, // 18: Vertical Display End (last visible scan line)
        0x28, // 19: Offset (number of bytes between start of one row to next in memory)
        0x1F, // 20: Underline Location (scan line where underline appears)
        0x96, // 21: Start Vertical Blank (line where vertical blank starts)
        0xB9, // 22: End Vertical Blank (line where vertical blank ends)
        0xA3, // 23: CRTC Mode Control (text mode, color, etc.)
        0xFF  // 24: Line Compare (used to detect split-screen effects, usually 0xFF)
    };

    for (int i = 0; i < 25; i++) {
        outb(0x3D4, i);
        outb(0x3D5, crtc[i]);
    }

    // 5. Graphics Controller: text/odd-even addressing
    uint8_t gc[9] = {0x00,0x00,0x00,0x00,0x00,0x10,0x0E,0x0F,0xFF};
    for (int i = 0; i < 9; i++) {
        outb(0x3CE, i);
        outb(0x3CF, gc[i]);
    }

    inb(0x3DA);
    // 6. Attribute Controller: text mode + unblank
    for (int i = 0; i < 16; i++) {
        outb(0x3C0, i);
        outb(0x3C0, i);
    }
    outb(0x3C0, 0x10); outb(0x3C0, 0x0C);
    outb(0x3C0, 0x12); outb(0x3C0, 0x0F);
    outb(0x3C0, 0x13); outb(0x3C0, 0x00);
    outb(0x3C0, 0x14); outb(0x3C0, 0x00);
    outb(0x3C0, 0x20); // unblank 

    // 7. Test: clear and print message
    volatile uint8_t* vga = (volatile uint8_t*)0xB8000;
    for (int i = 0; i < 80*25*2; i++) vga[i] = 0;

    for (int i = 0; i < 80*25; i++) {
        vga[i*2]   = 'A' + (i % 26);    // char
        vga[i*2+1] = 0x1F;      // white on blue
    }

    inb(0x3DA);
    outb(0x3C0, 0x20); // unblank 
}